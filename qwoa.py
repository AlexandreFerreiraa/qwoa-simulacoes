# -*- coding: utf-8 -*-
"""QWOA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VrXf5XT5COwPxPet8qlDnxxUFuz5HMdL
"""

!pip install qiskit

!pip install pylatexenc

import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import expm
from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import Operator, Statevector
from qiskit.visualization import plot_histogram

# --- 1. DEFINIÇÃO DO PROBLEMA (MARKOWITZ) ---
# Valores de custo extraídos da Tabela A2 do artigo
costs = np.array([
    0.0,
    0.19537791107281657,
    -0.1119084583542568,
    0.09592313540638248,
    -0.038186379903069514,
    -0.05124555365045395,
    0.12193130046716749,
    0.0                     # (Inválido/Auxiliar)
])

M = 7  # Tamanho do subespaço válido
N_Hilbert = 8 # Espaço físico de 3 qubits

# Matriz de Adjacência do Grafo Completo (apenas entre 0 e 6)
W_adj = np.zeros((N_Hilbert, N_Hilbert))
for i in range(M):
    for j in range(M):
        if i != j:
            W_adj[i, j] = 1.0

# --- 2. PARÂMETROS OTIMIZADOS (APÊNDICE B DO PAPER) ---
# Formato: Lista de tuplas (gamma, t) para cada camada k=1..p
params_by_p = {
    1: [(6.915, 0.688)],
    2: [(6.304, 0.606), (12.139, 0.756)],
    3: [(7.482, 0.596), (13.806, 0.669), (13.972, 0.716)],
    4: [(6.957, 0.536), (13.501, 0.635), (14.986, 0.676), (15.512, 0.760)],
    5: [(6.078, 0.528), (12.985, 0.591), (14.611, 0.656), (15.861, 0.724), (15.134, 0.801)],
    6: [(6.070, 0.042), (0.005, 1.383), (12.978, 0.591), (14.610, 0.656), (15.860, 0.724), (15.134, 0.801)]
}

def build_qwoa_circuit(p):
    # Constrói o circuito QWOA para profundidade p com portas rotuladas
    qc = QuantumCircuit(3)

    # Preparação do Estado Inicial (Superposição Uniforme em S')
    initial_amp = np.zeros(N_Hilbert)
    initial_amp[:M] = 1.0 / np.sqrt(M)
    qc.initialize(initial_amp, [0, 1, 2])
    qc.barrier(label='Init')

    # Aplicação das Camadas
    layers = params_by_p[p]
    for k, (gamma, t) in enumerate(layers):
        layer_num = k + 1

        # Unitário de Fase
        U_Q_mat = np.diag(np.exp(-1j * gamma * costs))
        op_Q = Operator(U_Q_mat)
        qc.unitary(op_Q, [0, 1, 2], label=f"U_Q({layer_num})\ng={gamma:.1f}")

        # 2. Unitário de Mistura
        U_W_mat = expm(-1j * t * W_adj)
        op_W = Operator(U_W_mat)
        qc.unitary(op_W, [0, 1, 2], label=f"U_W({layer_num})\nt={t:.3f}")

        qc.barrier()

    return qc

# EXECUÇÃO e RESULTADOS

exp_values = []
p_range = range(1, 7)
final_probs = []

print("Simulando iterações...")
for p in p_range:
    qc = build_qwoa_circuit(p)
    sv = Statevector.from_instruction(qc)
    probs = sv.probabilities()

    # Armazena dados
    final_probs.append(probs[:M])
    exp_val = np.dot(probs, costs)
    exp_values.append(exp_val)
    print(f"p={p}: Prob(Ótimo) = {probs[2]:.4f}, <Q> = {exp_val:.4f}")

# Evolução das Probabilidades
fig, axes = plt.subplots(2, 3, figsize=(15, 8), sharey=True)
states = [f"|{i}>" for i in range(M)]
colors = ['royalblue'] * M


for i, p in enumerate(p_range):
    ax = axes[i // 3, i % 3]
    ax.bar(states, final_probs[i], color=colors, edgecolor='k')
    ax.set_title(f"Iteração p={p}")
    ax.set_ylim(0, 1.05)
    ax.grid(axis='y', linestyle='--', alpha=0.5)

plt.suptitle("Amplificação de Probabilidade do Portfólio Ótimo", fontsize=16)
plt.tight_layout()
plt.show()

# Gráfico da Função Objetivo
plt.figure(figsize=(8, 5))
plt.plot(p_range, exp_values, 'o-', color='purple', lw=2)
plt.axhline(costs[2], color='r', ls='--', label='Mínimo Global')
plt.xlabel('Iterações (p)')
plt.ylabel('Valor Esperado <Q>')
plt.title('Convergência da Função de Custo')
plt.legend()
plt.grid(True)
plt.show()

#  PLOTAGEM DO CIRCUITO FINAL
from qiskit.visualization import plot_circuit_layout

print("\nGerando diagrama visual do circuito (p=6) com abreviação...")

# 1. Definição do Estilo (Cores)
# Mapeamos o 'name' da instrução para uma cor hex
custom_style = {
    'displaycolor': {
        'init_state': '#A9A9A9',  # Cinza claro para o estado inicial
        'u_q': '#DAA520',         # Goldenrod para Operador de Custo (Phase)
        'u_w': '#87CEEB',         # SkyBlue para Operador de Mistura (Walk)
    },
    'gatefacecolor': '#FFFFFF',
    'subfontsize': 10,
    'fontsize': 12
}

# 2. Construção do Circuito de Exibição (Apenas Início e Fim)
qc_display = QuantumCircuit(3)

# -- Passo A: Estado Inicial --
initial_amp = np.zeros(N_Hilbert)
initial_amp[:M] = 1.0 / np.sqrt(M)
# Hack: Criamos uma instrução customizada para poder colorir pelo nome 'init_state'
init_op = Operator(np.outer(initial_amp, initial_amp.conj()))
# Nota: Visualmente usamos initialize, mas para colorir forçamos um label/name
qc_display.initialize(initial_amp, [0, 1, 2])
# Acessamos a última instrução adicionada para mudar o nome para o estilo
qc_display.data[-1].operation.name = 'init_state'
qc_display.data[-1].operation.label = '|s_0>'

qc_display.barrier()

# -- Passo B: Primeira Iteração (p=1) --
gamma_1, t_1 = params_by_p[6][0] # Pega parâmetros da camada 1

# U_Q (Camada 1)
U_Q_mat = np.diag(np.exp(-1j * gamma_1 * costs))
op_Q = Operator(U_Q_mat).to_instruction()
op_Q.name = 'u_q'  # Nome chave para a cor
op_Q.label = f"U_Q\n(p=1)"
qc_display.append(op_Q, [0, 1, 2])

# U_W (Camada 1)
U_W_mat = expm(-1j * t_1 * W_adj)
op_W = Operator(U_W_mat).to_instruction()
op_W.name = 'u_w'  # Nome chave para a cor
op_W.label = f"U_W\n(p=1)"
qc_display.append(op_W, [0, 1, 2])

# -- Passo C: Quebra Visual (Break) --
# Adicionamos uma barreira com rótulo para indicar a omissão
qc_display.barrier(label='... (p=2 a p=5) ...')

# -- Passo D: Última Iteração (p=6) --
gamma_6, t_6 = params_by_p[6][-1] # Pega parâmetros da última camada

# U_Q (Camada 6)
U_Q_mat_6 = np.diag(np.exp(-1j * gamma_6 * costs))
op_Q_6 = Operator(U_Q_mat_6).to_instruction()
op_Q_6.name = 'u_q'
op_Q_6.label = f"U_Q\n(p=6)"
qc_display.append(op_Q_6, [0, 1, 2])

# U_W (Camada 6)
U_W_mat_6 = expm(-1j * t_6 * W_adj)
op_W_6 = Operator(U_W_mat_6).to_instruction()
op_W_6.name = 'u_w'
op_W_6.label = f"U_W\n(p=6)"
qc_display.append(op_W_6, [0, 1, 2])

# -- Medição Final (Opcional, apenas para fechar o circuito visualmente) --
qc_display.measure_all()

# 3. Plotagem
# style='iqp' é clean, mas passamos nosso dicionário para sobrescrever cores
qc_display.draw('mpl', style=custom_style, plot_barriers=True)